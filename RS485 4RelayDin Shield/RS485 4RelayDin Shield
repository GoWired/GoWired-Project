/*
 * This software is designed for various home automation nodes.
 * This is a the main file which makes use of some custom libraries that handles various sensors
 * (relays, buttons, thermometers, power meters, roller shutters) and communicates them 
 * with a controller using MySensors protocol.
 * 
 * To define some important variables, look at NodeDefinitions.h
 * 
 * Created by feanor-anglin (Domatic.org), 2018-01
 * 
 */

/*  *******************************************************************************************
 *                                      Includes
 *  *******************************************************************************************/

#include "NodeDefinitions.h"
#include "PowerSensor.h"
#include "UniversalInput.h"
#include <MySensors.h>

/*  *******************************************************************************************
 *                                      Globals
 *  *******************************************************************************************/
//Power Sensor
int ACVoltage = 230;                        // Typical AC voltage value for Power consumption calculation

// Timer
unsigned long LastUpdate = 0;               // Time of last update of interval sensors
bool CheckNow = true;
//int SensorToCheck = 0;

// Module Safety Indicators
bool OVERCURRENT_ERROR = false;             // Overcurrent error status
bool InformControllerES = false;            // Was controller informed about error?
//int ET_ERROR = false;                     // External thermometer status (0 - ok, 1 - checksum error, 2 - timeout error

/*  *******************************************************************************************
 *                                      Constructors
 *  *******************************************************************************************/
//Universal input constructor
UniversalInput UI[UI_SENSORS_NUMBER];
MyMessage msgUI(0, V_LIGHT);

// Power sensor constructor 
PowerSensor PS[UI_SENSORS_NUMBER];                             
MyMessage msgPS(0, V_WATT);

// Module Safety Indicators
MyMessage msgSI(0, V_STATUS);

/*  *******************************************************************************************
 *                                          Setup
 *  *******************************************************************************************/
void setup() {

  //SSerial.begin(4800);

  // Relays
  UI[FIRST_RELAY_ID].SetValues(3, RELAY_1);

  UI[FIRST_RELAY_ID+1].SetValues(3, RELAY_2);
    
  UI[FIRST_RELAY_ID+2].SetValues(3, RELAY_3);

  UI[FIRST_RELAY_ID+3].SetValues(3, RELAY_4);

  // Power Sensors
  PS[FIRST_RELAY_ID].SetValues(PS1_PIN);

  PS[FIRST_RELAY_ID+1].SetValues(PS2_PIN);

  PS[FIRST_RELAY_ID+2].SetValues(PS3_PIN);

  PS[FIRST_RELAY_ID+3].SetValues(PS4_PIN);
  
}

void presentation() {

  sendSketchInfo(SN, SV);

  // Relays
  present(FIRST_RELAY_ID, S_BINARY, "Relay 1");
    send(msgUI.setSensor(FIRST_RELAY_ID).set(UI[FIRST_RELAY_ID].NewState));

  present(FIRST_RELAY_ID+1, S_BINARY, "Relay 2");
    send(msgUI.setSensor(FIRST_RELAY_ID+1).set(UI[FIRST_RELAY_ID+1].NewState));

  present(FIRST_RELAY_ID+2, S_BINARY, "Relay 3");
    send(msgUI.setSensor(FIRST_RELAY_ID+2).set(UI[FIRST_RELAY_ID+2].NewState));

  present(FIRST_RELAY_ID+3, S_BINARY, "Relay 4");
    send(msgUI.setSensor(FIRST_RELAY_ID+3).set(UI[FIRST_RELAY_ID+3].NewState));

  // Power Sensors
  present(PS1_ID, S_POWER, "Power Sensor 1");

  present(PS2_ID, S_POWER, "Power Sensor 2");

  present(PS3_ID, S_POWER, "Power Sensor 3");

  present(PS4_ID, S_POWER, "Power Sensor 4");
  
  // Module Safety Indicators
  present(ES_ID, S_BINARY, "OVERCURRENT ERROR");
    
}

/*  *******************************************************************************************
 *                                      MySensors Receive
 *  *******************************************************************************************/
void receive(const MyMessage &message)  {

  if (message.type == V_STATUS) {
    if(message.sensor == ES_ID)  {
      OVERCURRENT_ERROR = message.getBool();
      if(OVERCURRENT_ERROR == false)  {
        InformControllerES = false;
      }
    }
    else  {
      for(int i=FIRST_RELAY_ID; i<FIRST_RELAY_ID+NUMBER_OF_RELAYS; i++) {
        if(message.sensor == i) {
          UI[message.sensor].NewState = message.getBool();
          UI[message.sensor].SetRelay();
          CheckNow = true;
        }
      }
    }
  }
}

/*  *******************************************************************************************
 *                                      Power Sensor
 *  *******************************************************************************************/
void PSUpdate(int Sensor)  {
  
  send(msgPS.setSensor(Sensor).set(PS[Sensor].CalculatePower(PS[Sensor].MeasureAC(), ACVoltage), 0));
}

/*  *******************************************************************************************
 *                                      Main Loop
 *  *******************************************************************************************/
void loop() {

  // Safety check
  for(int i=FIRST_RELAY_ID; i<FIRST_RELAY_ID+NUMBER_OF_RELAYS; i++) {
    OVERCURRENT_ERROR = PS[i].ElectricalStatus(PS[i].MeasureAC());
    if(OVERCURRENT_ERROR) {
      break;
    }
  }
  
  if((millis() > LastUpdate + INTERVAL) || (CheckNow == true))  {
    for(int i=FIRST_RELAY_ID; i<FIRST_RELAY_ID+NUMBER_OF_RELAYS; i++) {
      if(UI[i].NewState == RELAY_ON)  {
        PSUpdate(i+NUMBER_OF_RELAYS);
      }
      else  {
        send(msgPS.setSensor(i+NUMBER_OF_RELAYS).set(0));
      }
    }
    LastUpdate = millis();
    CheckNow = false;
  }

  // Handling safety procedures
  if(OVERCURRENT_ERROR == true && InformControllerES == false) {
    // AC current to big
    // Turn off relays/triacs
    for(int i=FIRST_RELAY_ID; i<FIRST_RELAY_ID+NUMBER_OF_RELAYS; i++)  {
      UI[i].NewState = RELAY_OFF;
      UI[i].SetRelay();
      send(msgUI.setSensor(i).set(UI[i].NewState));
    }
    send(msgSI.setSensor(ES_ID).set(OVERCURRENT_ERROR));
    InformControllerES = true;
  }
  
  wait(LOOP_TIME);
}
/*
 * 
 * EOF
 * 
 */
